// Copyright (c) 2012-2013 PPCoin developers
// Copyright (c) 2013 Primecoin developers
// Copyright (c) 2017-2018 eBoost Developers
// Distributed under conditional MIT/X11 software license,
// see the accompanying file COPYING
//
// The synchronized checkpoint system is first developed by Sunny King for
// ppcoin network in 2012, giving cryptocurrency developers a tool to gain
// additional network protection against 51% attack.
// 
// Enforced ACP added to eBoost 0.14.3 by Matt Smith, 2018.
//
// Concepts
//
// In the network there can be a privileged node known as 'checkpoint master'.
// This node can send out checkpoint messages signed by the checkpoint master
// key. Each checkpoint is a block hash, representing a block on the blockchain
// that the network should reach consensus on.
//
// Besides verifying signatures of checkpoint messages, each node also verifies
// the consistency of the checkpoints. If a conflicting checkpoint is received,
// it means either the checkpoint master key is compromised, or there is an
// operator mistake. In this situation the node would discard the conflicting
// checkpoint message and display a warning message. This precaution controls
// the damage to network caused by operator mistake or compromised key.
//
// Operations
//
// Acp master key can be established by using the 'makekeypair' command
// The public key in source code should then be updated and private key kept
// in a safe place.
//
// Any node can be turned into checkpoint master by setting the 'acp_master'
// configuration parameter with the private key of the checkpoint master key.
// Operator should exercise caution such that at any moment there is at most
// one node operating as checkpoint master. When switching master node, the
// recommended procedure is to shutdown the master node and restart as
// regular node, note down the current checkpoint by 'getcheckpoint', then
// compare to the checkpoint at the new node to be upgraded to master node.
// When the checkpoint on both nodes match then it is safe to switch the new
// node to checkpoint master.
//
// The configuration parameter 'acp_depth' specifies how many blocks
// should the checkpoints lag behind the latest block in auto checkpoint mode.
// A depth of 0 is the strongest auto checkpoint policy and offers the greatest
// protection against 51% attack. A negative depth means that the checkpoints
// should not be automatically generated by the checkpoint master, but instead
// be manually entered by operator via the 'sendcheckpoint' command. The manual
// mode is also the default mode (default value -1 for acp_depth).
//
// Command 'enforcecheckpoint' and configuration parameter 'checkpointenforce'
// are for the users to explicitly consent to enforce the checkpoints issued
// from checkpoint master. To enforce checkpoint, user needs to either issue
// command 'enforcecheckpoint true', or set configuration parameter
// checkpointenforce=1. The current enforcement setting can be queried via
// command 'getcheckpoint', where 'subscribemode' displays either 'enforce'
// or 'advisory'. The 'enforce' mode of subscribemode means checkpoints are
// enforced. The 'advisory' mode of subscribemode means checkpoints are not
// enforced but a warning message would be displayed if the node is on a 
// different blockchain fork from the checkpoint, and this is the default mode.
//

#include "acp.h"

#include "addrdb.h"
#include "base58.h"
#include "chainparams.h"
#include "checkpoints.h"
#include "uint256.h"
#include "utilstrencodings.h"
#include "rpc/server.h"
#include "net_processing.h"
#include "txdb.h"
#include "validation.h"
#include "validationinterface.h"

using namespace std;

const std::string CSyncCheckpoint::strMainPubKey = "04267007e652d1def54ce72da7a43a028329460eeb14351a1f5a83d3632cf3ab85a98111351905962952546fd94714ab28de0089d7264e3daf486a9dfd92ed69b0";
std::string CSyncCheckpoint::strMasterPrivKey = "";

bool IsACPMaster() { return !CSyncCheckpoint::strMasterPrivKey.empty(); }

uint256 hashSyncCheckpoint;
uint256 hashPendingCheckpoint;
CSyncCheckpoint checkpointMessage;
CSyncCheckpoint checkpointMessagePending;
uint256 hashInvalidCheckpoint;
CCriticalSection cs_hashSyncCheckpoint;
std::string strCheckpointWarning;
int64_t ACP_DEPTH;

bool ValidateSyncCheckpoint(uint256 hashCheckpoint)
{
    if (!mapBlockIndex.count(hashSyncCheckpoint))
        return error("ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s", hashSyncCheckpoint.ToString().c_str());

    if (!mapBlockIndex.count(hashCheckpoint))
        return error("ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s", hashCheckpoint.ToString().c_str());

    CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];
    CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];

    if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)
    {
        // Received an older checkpoint, trace back from current checkpoint
        // to the same height of the received checkpoint to verify
        // that current checkpoint should be a descendant block
        CBlockIndex* pindex = pindexSyncCheckpoint;
        while (pindex->nHeight > pindexCheckpointRecv->nHeight)
            if (!(pindex = pindex->pprev))
                return error("ValidateSyncCheckpoint: pprev1 null - block index structure failure");
        if (pindex->GetBlockHash() != hashCheckpoint)
        {
            hashInvalidCheckpoint = hashCheckpoint;
            return error("ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());
        }
        return false; // ignore older checkpoint
    }

    // Received checkpoint should be a descendant block of the current
    // checkpoint. Trace back to the same height of current checkpoint
    // to verify.
    CBlockIndex* pindex = pindexCheckpointRecv;
    while (pindex->nHeight > pindexSyncCheckpoint->nHeight)
        if (!(pindex = pindex->pprev))
            return error("ValidateSyncCheckpoint: pprev2 null - block index structure failure");
    if (pindex->GetBlockHash() != hashSyncCheckpoint) {
        hashInvalidCheckpoint = hashCheckpoint;
        return error("ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());
    }
    return true;
}

bool CSyncCheckpoint::CheckSignature()
{
    CPubKey key = CPubKey(ParseHex(CSyncCheckpoint::strMainPubKey));
    if (!key.IsFullyValid())
        return error("CSyncCheckpoint::CheckSignature() : CPubKey failed");

    if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))
        return error("CSyncCheckpoint::CheckSignature() : verify signature failed");

    // Now unserialize the data
    CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);
    sMsg >> *(CUnsignedSyncCheckpoint*)this;
    return true;
}

bool WriteSyncCheckpoint(const uint256& hashCheckpoint)
{
    if (!acpdb->WriteACP(hashCheckpoint))
        return error("WriteSyncCheckpoint(): failed to write to txdb sync checkpoint %s", hashCheckpoint.ToString().c_str());

    hashSyncCheckpoint = hashCheckpoint;
    return true;
}

bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)
{
    if (!CheckSignature())
        return false;
    LogPrintf("CSyncCheckpoint::ProcessSyncCheckpoint 1, hashCheckpoint=%s \n", hashCheckpoint.ToString().c_str());

    LOCK(cs_hashSyncCheckpoint);
    if (mapBlockIndex.count(hashCheckpoint) == 0) 
    {
        LogPrintf("CSyncCheckpoint::ProcessSyncCheckpoint 12, mapBlockIndex.count=%d \n", mapBlockIndex.count(hashCheckpoint));

        // We haven't received the checkpoint chain, keep the checkpoint as pending
        hashPendingCheckpoint = hashCheckpoint;
        checkpointMessagePending = *this;

        LogPrintf("CSyncCheckpoint::ProcessSyncCheckpoint 13, pending for sync-checkpoint %s\n", hashCheckpoint.ToString().c_str());

        // Ask this guy to fill in what we're missing
        // if (pfrom) {
        //     const CNetMsgMaker msgMaker(PROTOCOL_VERSION);
        //     g_connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKS, *pindexBestHeader, hashCheckpoint));
        //     LogPrintf("CSyncCheckpoint::ProcessSyncCheckpoint 14, asking for blocks\n");
        // }
        return false;
    }


    LogPrintf("CSyncCheckpoint::ProcessSyncCheckpoint 2 hashCheckpoint=%s, nHeight=%d \n", hashCheckpoint.ToString().c_str(), mapBlockIndex[hashCheckpoint]->nHeight);

    if (!ValidateSyncCheckpoint(hashCheckpoint))
        return false;

    bool IsInMainChain = true;
    BlockMap::iterator mi = mapBlockIndex.find(hashCheckpoint);
    if (mi == mapBlockIndex.end())
        IsInMainChain = false;

    if (!IsInMainChain)
        return error("ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s", hashCheckpoint.ToString().c_str());

    if (!WriteSyncCheckpoint(hashCheckpoint))
        return error("ProcessSyncCheckpoint(): failed to write sync checkpoint %s", hashCheckpoint.ToString().c_str());

    checkpointMessage = *this;
    hashPendingCheckpoint = uint256S("0");
    checkpointMessagePending.SetNull();
    LogPrintf("ProcessSyncCheckpoint: sync-checkpoint at %s\n", hashCheckpoint.ToString().c_str());
    
    return true;
}

bool SendSyncCheckpoint(uint256 hashCheckpoint)
{
    CSyncCheckpoint checkpoint;
    checkpoint.hashCheckpoint = hashCheckpoint;
    CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);
    sMsg << (CUnsignedSyncCheckpoint)checkpoint;
    checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());

    if (CSyncCheckpoint::strMasterPrivKey.empty()) 
        return error("SendSyncCheckpoint: acp_master key unavailable.");

    CBitcoinSecret vchSecret;
    if (!vchSecret.SetString(CSyncCheckpoint::strMasterPrivKey))
        return error("SendSyncCheckpoint: acp_master master key invalid");

    bool fGood = vchSecret.SetString(CSyncCheckpoint::strMasterPrivKey);
    if (!fGood)
        return error("SetCheckpointPrivKey: Invalid acp_master private key");

    CKey key = vchSecret.GetKey();
    if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))
        return error("SendSyncCheckpoint: Unable to sign acp, check acp_master private key?");

    if(!checkpoint.ProcessSyncCheckpoint(NULL))
    {
        if (fDebug)
            LogPrintf("WARNING: SendSyncCheckpoint: Failed to process checkpoint.\n");
        return false;
    }

    g_connman->ForEachNode([&checkpoint](CNode* pnode) {
        checkpoint.RelayTo(pnode);
    });

    return true;
}

bool SetCheckpointPrivKey(std::string strPrivKey)
{
    // Test signing a sync-checkpoint with genesis block
    CSyncCheckpoint checkpoint;
    checkpoint.hashCheckpoint = Params().GetConsensus().hashGenesisBlock;
    CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);
    sMsg << (CUnsignedSyncCheckpoint)checkpoint;
    checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());

    CBitcoinSecret vchSecret;
    if (!vchSecret.SetString(strPrivKey))
        return error("SetCheckpointPrivKey: Checkpoint master key invalid");
    
    bool fGood = vchSecret.SetString(strPrivKey);
    if (!fGood)
        return error("SetCheckpointPrivKey: Invalid private key");

    CKey key = vchSecret.GetKey();
    if (!key.IsValid())
        return error("SetCheckpointPrivKey: Private key outside allowed range");

    if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))
        return false;

    CSyncCheckpoint::strMasterPrivKey = strPrivKey;
    return true;
}

bool ResetSyncCheckpoint()
{
    // LOCK(cs_hashSyncCheckpoint);
    // const uint256& hash = Checkpoints::GetLastCheckpoint().GetBlockHash();
    // if (mapBlockIndex.count(hash) && !mapBlockIndex[hash]->IsInMainChain())
    // {
    //     // checkpoint block accepted but not yet in main chain
    //     LogPrintf("ResetSyncCheckpoint: SetBestChain to hardened checkpoint %s\n", hash.ToString().c_str());
        
    //     CValidationState state;
    //     if (!SetBestChain(state, mapBlockIndex[hash]))
    //     {
    //         return error("ResetSyncCheckpoint: SetBestChain failed for hardened checkpoint %s", hash.ToString().c_str());
    //     }
    // }
    // else if(!mapBlockIndex.count(hash))
    // {
    //     // checkpoint block not yet accepted
    //     hashPendingCheckpoint = hash;
    //     checkpointMessagePending.SetNull();
    //     if (fDebug)
    //       LogPrintf("ResetSyncCheckpoint: pending for sync-checkpoint %s\n", hashPendingCheckpoint.ToString().c_str());
    // }

    // if (!WriteSyncCheckpoint((mapBlockIndex.count(hash) && mapBlockIndex[hash]->IsInMainChain())? hash : Params().HashGenesisBlock()))
    //     return error("ResetSyncCheckpoint: failed to write sync checkpoint %s", hash.ToString().c_str());
    // if (fDebug)
    // LogPrintf("ResetSyncCheckpoint: sync-checkpoint reset to %s\n", hashSyncCheckpoint.ToString().c_str());
    return true;
}

bool CheckCheckpointPubKey()
{
    std::string strPubKey = "";
    if (!acpdb->ReadACPPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMainPubKey)
    {
        // write checkpoint master key to db
        if (!acpdb->WriteACPPubKey(CSyncCheckpoint::strMainPubKey))
            return error("CheckCheckpointPubKey(): failed to write new checkpoint master key to db");
        if (!ResetSyncCheckpoint())
            return error("CheckCheckpointPubKey(): failed to reset sync-checkpoint");
    }

    return true;
}

bool CheckSyncCheckpoint(const uint256& hashBlock, const CBlockIndex* pindexPrev)
{
    int nHeight = pindexPrev->nHeight + 1;

    LOCK(cs_hashSyncCheckpoint);
    // sync-checkpoint should always be accepted block
    if (mapBlockIndex.count(hashSyncCheckpoint) == 0)
        return false;

    const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];

    if (nHeight > pindexSync->nHeight)
    {
        // trace back to same height as sync-checkpoint
        const CBlockIndex* pindex = pindexPrev;
        while (pindex->nHeight > pindexSync->nHeight)
            if (!(pindex = pindex->pprev))
                return error("CheckSyncCheckpoint: pprev null - block index structure failure");
        if (pindex->nHeight < pindexSync->nHeight || pindex->GetBlockHash() != hashSyncCheckpoint)
            return false; // only descendant of sync-checkpoint can pass check
    }
    if (nHeight == pindexSync->nHeight && hashBlock != hashSyncCheckpoint)
        return false; // same height with sync-checkpoint
    if (nHeight < pindexSync->nHeight && !mapBlockIndex.count(hashBlock))
        return false; // lower height than sync-checkpoint
    return true;
}

// Automatically select a suitable sync-checkpoint 
uint256 AutoSelectSyncCheckpoint()
{
    // Search backward for a block with specified depth policy
    const CBlockIndex *pindex = pindexBestHeader;
    while (pindex->pprev && pindex->nHeight + ACP_DEPTH > pindexBestHeader->nHeight)
        pindex = pindex->pprev;
    return pindex->GetBlockHash();
}

UniValue setacpmaster(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 2)
        throw runtime_error(
            "setacpmaster \"privkey\"\n"
            "Returns true if you are now an acp master.\n"
        );

    string strPrivkey = request.params[0].get_str();

    UniValue result(UniValue::VOBJ);
    result.push_back(Pair("acp_master", SetCheckpointPrivKey(strPrivkey)));
    return result;
}

UniValue makekeypair(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 1)
        throw runtime_error(
            "makekeypair\n"
            "Get a random public/private key pair.\n"
        );

    CKey key;
    key.MakeNewKey(true);
    CPubKey pubkey = key.GetPubKey();
    assert(key.VerifyPubKey(pubkey));

    UniValue result(UniValue::VOBJ);
    result.push_back(Pair("PublicKey", HexStr(pubkey.Raw())));
    result.push_back(Pair("PrivateKey", CBitcoinSecret(key).ToString()));

    return result;
}

UniValue broadcastacp(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw runtime_error(
            "broadcastacp <blockhash>\n"
            "Send a synchronized checkpoint.\n");

    if (!IsACPMaster())
        throw runtime_error("Not an acp_master, first set acp_master in configuration and restart client. ");

    std::string strHash = request.params[0].get_str();
    uint256 hash = uint256S(strHash);

    if (!SendSyncCheckpoint(hash))
        throw runtime_error("Failed to send checkpoint, check log.");

    UniValue result(UniValue::VOBJ);
    CBlockIndex* pindexCheckpoint;

    result.push_back(Pair("synccheckpoint", hashSyncCheckpoint.ToString().c_str()));
    if (mapBlockIndex.count(hashSyncCheckpoint))
    {
        pindexCheckpoint = mapBlockIndex[hashSyncCheckpoint];
        result.push_back(Pair("height", pindexCheckpoint->nHeight));
        result.push_back(Pair("timestamp", (boost::int64_t) pindexCheckpoint->GetBlockTime()));
    }
    return result;
}

UniValue getacp(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 0)
        throw runtime_error(
            "getacp\n"
            "Show info of acp.\n");

    UniValue result(UniValue::VOBJ);
    CBlockIndex* pindexCheckpoint;

    result.push_back(Pair("synccheckpoint", hashSyncCheckpoint.ToString().c_str()));
    if (mapBlockIndex.count(hashSyncCheckpoint)) {
        pindexCheckpoint = mapBlockIndex[hashSyncCheckpoint];
        result.push_back(Pair("height", pindexCheckpoint->nHeight));
        result.push_back(Pair("timestamp", (boost::int64_t) pindexCheckpoint->GetBlockTime()));
    } else {
        result.push_back(Pair("height", "ERROR: checkpoint not found, maybe we are behind?"));
        result.push_back(Pair("timestamp", "ERROR: checkpoint not found, maybe we are behind?"));
    }

    if(IsACPMaster())
    {
        bool acp_breathing = IsACPMaster() && ACP_DEPTH > -1;
        result.push_back(Pair("acp_master", true));
        result.push_back(Pair("acp_depth", ACP_DEPTH));
        result.push_back(Pair("acp_breathing", acp_breathing));
    }

    return result;
}

UniValue setacpdepth(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw runtime_error(
            "setacpdepth <depth>\n"
            "Set acp depth\n");

    ACP_DEPTH = atoi64(request.params[0].get_str());

    UniValue result(UniValue::VOBJ);
    result.push_back(Pair("acp_depth", ACP_DEPTH));
    return result;
}

UniValue getacpdepth(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 0)
        throw runtime_error(
            "getacpdepth\n"
            "Get acp depth\n");

    UniValue result(UniValue::VOBJ);
    result.push_back(Pair("acp_depth", ACP_DEPTH));
    return result;
}

static const CRPCCommand commands[] =
{ //  category              name                      actor (function)         okSafeMode argNames
  //  --------------------- ------------------------  -----------------------  ---------- --------
    { "acp",                "makekeypair",            &makekeypair,            true,      {} },
    { "acp",                "setacpmaster",           &setacpmaster,           true,      {} },
    { "acp",                "broadcastacp",           &broadcastacp,           true,      {} },
    { "acp",                "getacp",                 &getacp,                 true,      {} },
    { "acp",                "getacpdepth",            &getacpdepth,            true,      {} },
    { "acp",                "setacpdepth",            &setacpdepth,            true,      {} },
};

void RegisterAcpRPCCommands(CRPCTable &t)
{
    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)
        t.appendCommand(commands[vcidx].name, &commands[vcidx]);
}
